= Analyse de l'application
:toc:
:toc-title: Sommaire
:toclevels: 4

[underline]#Tilian HURÉ et Hugo WENDJANEH# *(2A)*

{empty} +

== I. Contexte
[.text-justify]
Dans le contexte de la SAE 4.01 nous avons eu à refactorer l’entièreté d’une application Java Swing permettant la gestion de tournois de Belote. Le code source mis à disposition était complet et fonctionnel mais présentait une très grosse quantité de défauts sur plusieurs aspects, que ce soit en termes de lisibilité, de simplicité, de maintenabilité ou d’optimisation.

[.text-justify]
Notre binôme est donc intervenu dans le but de refactorer l’application autant que possible. Ce document détaille l’ensemble des modifications qui ont été apportées au code source de cette dernière.

== II. Refactoring
=== 1) Conversion en projet Maven
[.text-justify]
Nous avons d’abord converti le projet en un projet https://maven.apache.org/[Maven]. Cela permet une meilleure gestion de l’application, que ce soit pour sa compilation son exécution, mais aussi pour l’exécution de tests et l’ajout de librairies externes, etc.

==== 1.1) Scripts d’exécution du code source
[.text-justify]
Maven permet l’exécution de tâches (compilation, import des packages, nettoyage, etc) par l'intermédiaire de commandes utilisables dans un terminal. Nous avons donc réalisé deux scripts d’exécutions composés de ces dernières afin de compiler et lancer facilement et correctement le code source de l’application. Nous avons produit un script BAT et un script BASH afin de permettre l’exécution sous Windows ou sous Linux.
[source, bash]
----
:: Nettoyage, installation des packages et compilation
call mvn clean install compile package

:: Exécution via le JAR généré par Maven
java -jar ./target/belote-1.0-jar-with-dependencies.jar
----

{empty} +

=== 2) Conversion avec l'utilisation du MVC pattern
[.text-justify]
L'ancienne structure de l'application ne comprenait que 5 classes Java toutes dans un même répertoire. Les classes de type view et model étaient mélangées et s'occupaient de plusieurs tâches alors que l'utilisation de Java est destinée à créer des classes s'occupant de tâches précises.

image::images/[Ancienne structure]

==== 2.1) Nouvelle structure
[.text-justify]
Nous avons restructuré l'application afin qu'elle respecte le principe du *MVC* pattern. Le Model-View-Controller pattern permet de décomposer une application en 3 parties :

* model : manipulation et représentation des données de l'application
* view : composants et interfaces graphiques
* controller/control : liaisons et contrôle des données entre les view et les model

[.text-justify]
La nouvelle structure comprend les 3 répertoires principaux du MVC :

* `view` : composant et fenêtre Java Swing s'occupant uniquement de l'interface graphique
* `model` : classes de manipulation et de représentation des données (pour les matchs, les équipes, tournois)
* `control` : classes s'occupant des liaisons entre l'interface, les données et la base de données (requêtes SQL)

Nouvelle arborescence complète :
[source]
----
java
├───control
│   ├───actors
│   │   ├───actors
│   │   └───specialQueries
│   │       └───specialQueries
│   └───dialogs
├───model
├───resources
├───types
└───view
----

==== 2.2) Ajout d’une fabrique d’acteurs
[.text-justify]
Nous avons utilisé le pattern de conception *Factory* permettant d'instancier des objets dont le type est dérivé d'un type abstrait, la classe exacte de l'objet n'étant donc pas connue par l'appelant.

[.text-justify]
Ce pattern a été utilisé pour implémenter des acteurs pour la partie control de l'application. Nous avons d'abord développé une classe abstraite `Actor.java` définissant des méthodes permettant :

* l'exécution de requêtes SQL classiques (méthodes get pour SELECT, add pour INSERT, set pour UPDATE et remove pour DELETE)

[source, java]
----
/**
 * Exécute une requête SELECT sur la table correspondante avec les filtres,
 *   les paramètres de la clause WHERE et les colonnes d'ordonnancement fournis en paramètres.
 * @param filtres : la liste des colonnes à sélectionner
 * @param parametresWhere : la map des paramètres de la clause WHERE
 * @param orderingColumns : la liste des colonnes d'ordonnancement
 * @return le résultat de la requête sous forme de ResultSet
 * @throws Exception si une erreur se produit lors de l'exécution de la requête
 */
public ResultSet get(List<TableAttributType> filtres, Map<TableAttributType, String> parametresWhere,
    List<TableAttributType> orderingColumns) throws Exception

/**
 * Ajoute un enregistrement dans la table avec les paramètres donnés.
 * @param parametresValues Une map contenant les paramètres et leur valeur associée.
 * @throws Exception si parametresValues est null ou vide
 */
public void add(Map<TableAttributType, String> parametresValues) throws Exception

/**
 * Modifie un ou plusieurs enregistrements de la table avec les valeurs passées en paramètre.
 * Si le paramètre parametresValues est nul ou vide, une exception est levée.
 * Si le paramètre parametresWhere est non nul et non vide, la modification se fait seulement sur
 *   les enregistrements qui correspondent aux conditions spécifiées dans parametresWhere.
 * Les paramètres passés en argument doivent être valides selon les attributs de la table correspondante.
 * @param parametresValues : un Map de TableAttributType et String contenant les valeurs à modifier pour chaque attribut de la table.
 * @param parametresWhere : un Map de TableAttributType et String contenant les conditions pour la sélection des enregistrements à modifier.
 * @throws Exception si le paramètre parametresValues est nul ou vide.
 * @throws Exception si une erreur SQL survient lors de l'exécution de la requête de modification.
 */
public void set(Map<TableAttributType, String> parametresValues,
    Map<TableAttributType, String> parametresWhere) throws Exception

/**
 * Supprime un ou plusieurs enregistrements dans la table correspondante en fonction des paramètres de filtrage fournis.
 * @param parametresWhere un Map contenant les colonnes de la table à utiliser comme filtres et leur valeur correspondante
 * @throws Exception si aucun paramètre de filtrage n'est fourni, ou si une erreur survient lors de l'exécution de la requête SQL
 */
public void remove(Map<TableAttributType, String> parametresWhere) throws Exception
----

* l'exécution de requêtes SQL plus complexes dites "spéciales" (requêtes imbriquées, prédicats complexes, etc)

[source, java]
----
/**
 * Exécute une requête spéciale en fonction du type de requête spéciale et du type de requête spécifié.
 * Les paramètres de requête sont optionnels et dépendent du type de requête spéciale.
 * @param sqt : le type de requête spéciale à exécuter.
 * @param qt : le type de requête à exécuter (QUERY ou UPDATE).
 * @param parametres : les paramètres de requête pour la requête spéciale (optionnels).
 * @return Le résultat de la requête sous forme de ResultSet (si le type de requête est QUERY)
 *   ou null (si le type de requête est UPDATE).
 * @throws Exception si une erreur se produit lors de l'exécution de la requête.
 */
public ResultSet specialQuery(SpecialQueryType sqt, QueryType qt, List<String> parametres) throws Exception
----

* le formatage des paramètres des méthodes pour les adapter à des requêtes SQL

[source, java]
----
/**
* Formate les valeurs d'un map de paramètres en appelant la méthode "formateParametresValue" pour chaque valeur.
 * Les clés du map sont de type "TableAttributType" et les valeurs sont de type "String".
 * @param parametres : Map de paramètres à formater.
 * @return Map de paramètres formatés.
 */
private Map<TableAttributType, String> formateParametresMap(Map<TableAttributType, String> parametres)

/**
 * Cette méthode prend une liste de paramètres et renvoie une nouvelle liste où chaque paramètre est formaté pour être utilisé dans une requête SQL.
 * @param parametres : la liste de paramètres à formater.
 * @return La liste de paramètres formatée pour une utilisation dans une requête SQL.
 */
private List<String> formateParametresList(List<String> parametres)

/**
 * Formate une valeur de paramètre selon le type de données attendu dans la base de données.
 * Si la valeur est un entier, elle est convertie en chaîne de caractères. Si la valeur est "null",
 *   elle est remplacée par le mot-clé SQL "NULL".
 *   Sinon, la valeur est entourée de guillemets simples pour être considérée comme une chaîne de caractères en SQL.
 * @param value : la valeur à formater
 * @return la valeur formatée
 */
private String formateParametresValue(String value)
----

avec le constructeur suivant :

[source, java]
----
/**
 * Constructeur de la classe Actor. Initialise une connexion à la base de données et définit le nom de table pour l'acteur.
 * @param tableName : le nom de la table correspondante dans la base de données
 */
public Actor(String tableName) {
    try {
        this.ddbStatement = DialogDataBase.getStatement();
        this.tableName = tableName;
    } catch (Exception e) {
        Fenetre.afficherErreur("Erreur lors de la création d'un acteur pour le type " + tableName +
                ", un acteur ne peut pas être créé sans une connexion à la base de données.");
    }
}
----

[.text-justify]
D'autres classes héritent de la classe abstraite pour chaque type d'acteur, il y a donc principalement `ActorEquipe.java`, `ActorMatch.java` et `ActorTournoi.java`. Exemple d'une classe acteur :

[source, java]
----
public class ActorEquipe extends Actor {

    /**
     * Constructeur par défaut qui appelle le constructeur de la classe mère avec le nom "Equipes".
     */
    public ActorEquipe() {
        super("Equipes");
    }

}
----

[.text-justify]
Une méthode de la classe `ActorFactory.java`, renvoie une instance de la classe d'un en fonction d'un type d'acteur donné.

[source, java]
----
/**
 * Retourne une instance de la classe Actor correspondante au type d'acteur spécifié.
 * @param at : le type d'acteur
 * @return une instance de la classe Actor correspondante
 * @throws Exception si le type d'acteur n'est pas trouvé
 */
public static Actor getActor(ActorType at) throws Exception {
    switch (at) {
        case EQUIPE:
            return new ActorEquipe();
        case MATCH:
            return new ActorMatch();
        case TOURNOI:
            return new ActorTournoi();
        default:
            throw new Exception("Le type d'acteur " + at + " n'a pas été trouvé.");
    }
}
----

[.text-justify]
Les acteurs sont utilisés par des classes dialogs construisant des requêtes à partir des données récupérées depuis les classes model et view.

==== 2.3) Ajout de dialogs pour les acteurs et la base de données
[.text-justify]
Nous avons d'abord créé une classe dialog `DialogDataBase.java` permettant la connexion avec la base de données de l'application en fonction d'un fichier de configuration, et produisant un objet `Statement` utilisé par les acteurs pour exécuter des requêtes SQl. Pour assurer que ces dernières sont exécutées depuis une même connexion avec un même statement, nous avons utilisé le pattern *Singleton*. Ce dernier permet de s'assurer qu'une classe ne produise qu'une seule et unique instance. Le dialog de la base de données doit d'abord être initialisé avec certaines données, et une méthode `getStatement` permet de récupérer le statement généré.

[.text-justify]
Nous avons ensuite créé un dialog pour chaque type d'acteur, soient les classes `DialogEquipe`, `DialogMatch` et `ActorTournoi`. Ces dernières permettent la liaison des données entre les classes view et model en implémentant des méthodes spécifiques construisant des requêtes simple et spéciales en utilisant la fabrique d'acteurs pour les exécuter. Exemple de méthode construisant et exécutant une requête :

[source, java]
----
/**
 * Récupère le numéro d'une équipe donnée.
 * @param idEquipe : ID de l'équipe.
 * @return Résultat de la requête SQL.
 * @throws Exception Si une erreur se produit lors de l'exécution de la requête.
 */
public ResultSet getNumDUneEquipe(Integer idEquipe) throws Exception {
    List<TableAttributType> filtres = new ArrayList<>();
    filtres.add(TableAttributType.NUM_EQUIPE);
    Map<TableAttributType, String> parametresWhere = new HashMap<>();
    parametresWhere.put(TableAttributType.ID_EQUIPE, idEquipe + "");
    return this.actorEquipe.get(filtres, parametresWhere, null);
}
----

Les paramètres sont principalement formatés avec des Map, la clé étant le nom de la colonne de la table correspondante et la valeur étant celle à insérer ou modifier. Le type `TableAttributType` (enum) permet de désigner un nom de colonne précis en éviter les risques d'erreur.

*TODO (from ici)*

==== 2.4) Redirection des messages d’erreur vers la fenêtre view
Messages d’erreur rédigés pour chaque erreur relevées (et autre) et redirigé vers la view

Fonction statique permettant l’affichage d’erreurs compréhensibles pour l’utilisateur dans la fenêtre d’affichage (en conservant les prints pour les développeurs)
Fonction statique pour demander le nom d’un tournoi

{empty} +

=== 3) Ajout de classes
==== 3.1) Ajout de classes Enum
Dans le package “types”

* Types d’acteur
* Types de requête (lecture/QUERY ou modification/UPDATE)
* Types de requête spéciale
* Statuts d’un tournoi
* Type des attributs des tables SQL

==== 3.2) Ajout d’une fabrique à requêtes spéciales
Pattern de conception Factory

Classe abstraite SpecialQuery : requête SQL sous forme de String

Héritage pour chaque requêtes spéciales nécessaires

Classe SpeicalQueryFactory renvoyant une instance de la classe d’une requête spéciale en fonction d’un type de requête spéciale

Requêtes spéciales fabriquées dans les dialogs correspondant et exécutées par les acteurs

==== 3.4) Ajout d’une classe “Tools”
Classe avec des méthodes statiques, utiles et générales pouvant être utilisées dans n’importe quelle classe

{empty} +

=== 4) Reformatage, homogénéisation et contrôle du code
==== 4.1) Mise au propre des classes
Indentation, espaces, etc

Renommage variables, classes et méthodes (normes de nomenclature, camelCase, etc), plus d’hétérogénéité, plus lisible et en accord avec la fonctionnalité correspondante

Suppression de bouts de code inutiles, du code redondant

Simplification de bouts de code (condition, boucles, etc)

Autres bonnes pratiques, utilisation de switch à la place de if si nécessaire, etc

==== 4.2) Contrôle de la récupération des données de requêtes
Méthodes de dialogs retournant le résultat de requêtes SQL (simple ou complexe), méthodes getInt ou getString pour récupérer les données correspondant aux noms/numéros de column dans la requête

Utilisation du type TableAttributsType afin d’éviter de saisir les columns en dur et ainsi éviter les erreurs

Utilisation également dans les dialogs pour fabriquer des requêtes avec les bons noms de columns pour les paramètres

==== 4.3) Reformatage de la classes Belote/BeloteApp
Utilisation seulement pour initialiser le dialog avec la base de données et lancer l’application

==== 4.4) Fichier de configuration database.properties
Fichier avec les données de connexion de la base de données utilisé par l’application

{empty} +

=== 5) Documentation
==== 5.1) Rédaction de la Javadoc
Rédaction Javadoc pour chaque fonctions et classes (en français) afin de rendre plus explicite leur principe, fonctionnement et utilisation

==== 5.2) Cahier de recette de l’application
Plans de tests pour attester du bon fonctionnement de l’application avec action à effectuer, résultats attendus et résultats obtenus pour chaque cas pour chaque fonctionnalités utilisateur
